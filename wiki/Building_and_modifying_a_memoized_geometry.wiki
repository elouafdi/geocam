#summary How to encode and modify a geometry written as a "memoized-pipeline."

=Working with a "memoized-pipeline" data structure (WORK IN PROGRESS)=

==Key Words==
geometry, memoized-pipeline, extending, modifying, data structure, geoquant, quantities, singleton, observer, observable

==Authors==
    * Alex Henniges
    * Joseph Thomas

== Introduction ==
The memoized-pipeline is a data structure we developed for investigating geometries defined on triangulations. It is particularly suited to the situation in which we need to specify the values of some geometric quantities (independent variables) and then need to rapidly calculate the values of some other quantities (the dependent variables). Basically, we achieve this speedup by trading space for time. Usually, the definitions of the dependent variables have many intermediate values in common. By saving these values the first time we compute them, and then reusing them later, we can avoid a lot of useless recalculation. This strategy of saving calculated values, which can be found in most algorithms textbooks, is called "memoization." 

In implementing various geometries, we have already developed code and techniques for making memoization an automatic part of encoding a geometry. In this tutorial, we describe how to take advantage of this existing code.

== Implementation Details ==
The underlying implementation of the pipeline is designed to solve two problems in a fairly user-friendly way:
  # We would like to be able to identify geometric quantities with positions on the triangulation. For example, we can speak of the dihedral angle associated with a particular edge on a tetrahedron. We would like to be able to write code in the same way.
  # We would like memoization to be nearly automatic. In other words, when writing a particular quantity, the programmer shouldn't have to think much about what happens to memoize that quantity's value.
 
Taking the programmer's perspective, we can view quantities as being specified by 3 pieces of information:
  # A position on the triangulation.
  # A definition of the other quantities (if any) needed to calculate the value of the current quantity, and where those quantities can be found on the triangulation.
  # A formula for calculating a quantity's value, given the values of the other quantities it depends on.

Usually, specifying just these 3 pieces of information is enough to create a new type of quantity. To help speed the development of quantities, we have developed a Ruby script, `makeQuantity.rb`, that generates much of the source code. This can be invoked at the command line as follows:
{{{
> ruby makeQuantity.rb [quantity]
}}}
This produces two files, `[quantity].h` and `[quantity].cpp`.

=== The "anatomy" of `quantity.h` ===
In `C++`, header files serve several purposes. Among other uses, a header file can:
 * Specify dependencies on other parts of the project.   
 * Define an interface for other parts of your project to use. This includes:
    * Definitions for new data-types (like classes).
    * Definitions for procedure calls (what arguments a procedure takes, and what it returns).
By default, `makeQuantity.rb` gives you the following header file to use (here, we chose `quantity/QUANTITY` as the quantity name, in practice, this is filled out by the script). 
{{{
#ifndef QUANTITY_H_
#define QUANTITY_H_

#include "geoquant.h"
#include "triposition.h"

/******************REGION 1*******************
 * This is where you load the headers of the *
 * quantities you require.                   *
 *********************************************/

class quantity : public virtual GeoQuant {
protected:
  quantity( SIMPLICES );
  void recalculate();
  /****************REGION 2*********************
   * The quantity references you need go here. *
   *********************************************/

public:
  ~quantity();
  static quantity* At( SIMPLICES );
  static void CleanUp();
};
#endif /* QUANTITY_H_ */
}}}

The two important areas of the header are labeled `REGION 1` and `REGION 2`. In region 1, you specify the header files for the quantities and utilities you use in the rest of your quantity. These `#include` statements can be thought of as providing definitions for the data and procedures you want to use in building your quantity. In region 2, you specify the data associated with a given instance of the quantity; typically this amounts to several references to other quantities, or a data structure that manages references to other quantities. Lastly, you will need to modify the region tagged `SIMPLICES` so that it reflects a collection of simplices that describe your quantity's position on the triangulation.

=== The "anatomy" of `quantity.cpp` ===

In general, a `.cpp` file provides the internal implementation to support the operations described in the corresponding header file. Editing this file will be a little more complicated. By default, `makeQuantity.rb` will produce the following `.cpp` file: 
{{{
#include "quantity.h"

#include <map>
#include <new>
using namespace std;

#define map<TriPosition, quantity*, TriPositionCompare> quantityIndex 
static quantityIndex* Index = NULL;

quantity::quantity( SIMPLICES ){
  /* REGION 1 */
}

quantity::~quantity(){
  /* REGION 2 */
}

void quantity::recalculate(){
  /* REGION 3 */
}

quantity* quantity::At( SIMPLICES ){
  TriPosition T( NUMSIMPLICES, SIMPLICES );
  if( Index == NULL ) Index = new quantityIndex();
  quantityIndex::iterator iter = Index->find( T );

  if( iter == Index->end() ){
    quantity* val = new quantity( SIMPLICES );
    Index->insert( make_pair( T, val ) );
    return val;
  } else {
    return iter->second;
  }
}

void quantity::CleanUp(){
  if( Index == NULL ) return;
  quantityIndex::iterator iter;
  for(iter = Index->begin(); iter != Index->end(); iter++)
    delete iter->second;
  delete Index;
}
}}}

There are a few smaller areas to fill out, but in general defining the quantity requires the following three definitions:
  * Region 1 specifies how to obtain references on the quantities your quantity depends on. Typically, this will involve using the input simplex information and some utilities for inspecting the triangulation to look up the quantities needed for later calculations.
  * Region 2 specifies how to release any data structures built up using dynamic memory. In many cases, this field will be left blank.
  * Region 3 specifies how to calculate the value of an instance of the quantity. Typically, this will occur in two steps:
    # Using the quantity references obtained in region 1, we acquire the current values of the quantities used in the calculation.
    # Using a formula and the values found in step 1, we calculate the value of the current quantity.

== An Extended Example ==
Perhaps the easiest way to understand the system is by examining a few working quantities. In this example, we consider the quantity `dual_area_segment` discussed in [1].

{{{
#ifndef DUALAREASEGMENT_H_
#define DUALAREASEGMENT_H_

#include <map>
#include <new>
using namespace std;

#include "geoquant.h"
#include "triposition.h"

#include "edge_height.h"
#include "face_height.h"

class DualAreaSegment : public virtual GeoQuant {
private:
  EdgeHeight* hij_k;
  EdgeHeight* hij_l;
  FaceHeight* hijk_l;
  FaceHeight* hijl_k;

protected:
  DualAreaSegment( Edge& e, Tetra& t );
  void recalculate();

public:
  ~DualAreaSegment();
  static DualAreaSegment* At( Edge& e, Tetra& t );
  static void CleanUp();
  static void Record( char* filename );
};

#endif /* DUALAREASEGMENT_H_ */
}}}



{{{

#include "dualareasegment.h"
#include "miscmath.h"

#include <stdio.h>

typedef map<TriPosition, DualAreaSegment*, TriPositionCompare> DualAreaSegmentIndex;
static DualAreaSegmentIndex* Index = NULL;

DualAreaSegment::DualAreaSegment( Edge& e, Tetra& t ){
  StdTetra st = labelTetra( t, e );

  Face& fa123 = Triangulation::faceTable[ st.f123 ];
  Face& fa124 = Triangulation::faceTable[ st.f124 ];

  hij_k = EdgeHeight::At( e, fa123 );
  hij_l = EdgeHeight::At( e, fa124 );

  hijk_l = FaceHeight::At( fa123, t );
  hijl_k = FaceHeight::At( fa124, t );

  hij_k->addDependent(this);
  hij_l->addDependent(this);
  hijk_l->addDependent(this);
  hijl_k->addDependent(this);
}

void DualAreaSegment::recalculate(){
  double Hij_k = hij_k->getValue();
  double Hijk_l = hijk_l->getValue();
  double Hij_l = hij_l->getValue();
  double Hijl_k = hijl_k->getValue();

  value = 0.5*(Hij_k * Hijk_l + Hij_l * Hijl_k);
}

DualAreaSegment::~DualAreaSegment(){}

DualAreaSegment* DualAreaSegment::At( Edge& e, Tetra& t ){
  TriPosition T( 2, e.getSerialNumber(), t.getSerialNumber() );
  if( Index == NULL ) Index = new DualAreaSegmentIndex();
  DualAreaSegmentIndex::iterator iter = Index->find( T );

  if( iter == Index->end() ){
    DualAreaSegment* val = new DualAreaSegment( e, t );
    Index->insert( make_pair( T, val ) );
    return val;
  } else {
    return iter->second;
  }
}

void DualAreaSegment::CleanUp(){
  if( Index == NULL ) return;
  DualAreaSegmentIndex::iterator iter;
  for(iter = Index->begin(); iter != Index->end(); iter++)
    delete iter->second;
  delete Index;
}

}}}


== Common Mistakes ==
A panoply of debugging hints should go here.

== Fancier Tricks ==
Techniques for less common quantities go here.

== Limitations, Areas to Improve ==
Discussion of the current topological assumptions our code makes.

== Works Cited ==
[1] A bibliographic reference goes here...