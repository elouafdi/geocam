#summary How to encode and modify a geometry written as a "memoized-pipeline."

=Working with a "memoized-pipeline" data structure (ROUGH DRAFT)=

==Key Words==
geometry, memoized-pipeline, extending, modifying, data structure, geoquant, quantities, singleton, observer, observable

==Authors==
    * Alex Henniges
    * Joseph Thomas

== Introduction ==
The memoized-pipeline is a data structure we developed for investigating geometries defined on triangulations. It is particularly suited to the situation in which we need to specify the values of some geometric quantities (independent variables) and then need to rapidly calculate the values of some other quantities (the dependent variables). Basically, we achieve this speedup by trading space for time. Usually, the definitions of the dependent variables have many intermediate values in common. By saving these values the first time we compute them, and then reusing them later, we can avoid a lot of useless recalculation. This strategy, which can be found in most algorithms textbooks, is called "memoization." 

In implementing various geometries, we have already developed code and techniques for making memoization an automatic part of encoding a geometry. In this tutorial, we describe how to make use of this code.  

== Implementation Details ==
The underlying implementation of the pipeline is designed to solve two problems in a fairly user-friendly way:
  # We would like to be able to identify geometric quantities with positions on the triangulation. For example, when doing mathematics we can speak of the dihedral angle associated with a particular edge on a tetrahedron. We would like to be able to write code in the same way.
  # We would like memoization to be nearly automatic. In other words, when writing a particular quantity, the programmer shouldn't have to think much about what happens to memoize that quantity's value.
 
We view quantities as being specified by 3 pieces of information:
  # A position on the triangulation.
  # A definition of the other quantities (if any) needed to calculate the value of the current quantity, and where those quantities can be found on the triangulation.
  # A formula for calculating a quantity's value, given the values of the other quantities it depends on.

Usually, specifying just these 3 pieces of information is enough to create a new type of quantity. To help speed the development of quantities, we have developed a Ruby script, `makeQuantities.rb`, that generates much of the source code. This can be invoked at the command line as follows:
{{{
> ruby makeQuantities.rb [quantity_name]
}}}
This produces two files, `[quantity_name].h` and `[quantity_name].cpp`.

=== The anatomy of `quantity_name.h` ===
{{{
#ifndef QUANTITY_H_
#define QUANTITY_H_

#include <map>
#include <new>
using namespace std;

#include "geoquant.h"
#include "triposition.h"

class #{name} : public virtual GeoQuant {
protected:
  QUANTITY( SIMPLICES );
  void recalculate();

public:
  ~QUANTITY();
  static QUANTITY* At( SIMPLICES );
  static void CleanUp();
};
#endif /* QUANTITY_H_ */
}}}

=== The anatomy of `quantity_name.cpp` ===
{{{


QUANTITYIndex* Index = NULL;

QUANTITY::QUANTITY( SIMPLICES ){}

void QUANTITY::recalculate(){}

QUANTITY::~QUANTITY(){}

QUANTITY* QUANTITY::At( SIMPLICES ){
  TriPosition T( NUMSIMPLICES, SIMPLICES );
  if( Index == NULL ) Index = new QUANTITYIndex();
  QUANTITYIndex::iterator iter = Index->find( T );

  if( iter == Index->end() ){
    QUANTITY* val = new QUANTITY( SIMPLICES );
    Index->insert( make_pair( T, val ) );
    return val;
  } else {
    return iter->second;
  }
}

void QUANTITY::CleanUp(){
  if( Index == NULL ) return;
  QUANTITYIndex::iterator iter;
  for(iter = Index->begin(); iter != Index->end(); iter++)
    delete iter->second;
  delete Index;
}


}}}
== Example ==
Adding a quantity to the Einstein-Hilbert-Regge geometry. (More details and diagrams will go here)

== Common Mistakes ==
A panoply of debugging hints should go here.

== Fancier Tricks ==
Techniques for less common quantities go here.

== Limitations, Areas to Improve ==



Discussion of the current topological assumptions our code makes.