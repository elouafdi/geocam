#summary How to encode and modify a geometry written as a "memoized-pipeline."

=Working with a "memoized-pipeline" data structure (WORK IN PROGRESS)=

==Key Words==
geometry, memoized-pipeline, extending, modifying, data structure, geoquant, quantities, singleton, observer, observable

==Authors==
    * Alex Henniges
    * Joseph Thomas

== Introduction ==
The memoized-pipeline is a data structure we developed for investigating geometries defined on triangulations. It is particularly suited to the situation in which we need to specify the values of some geometric quantities (independent variables) and then need to rapidly calculate the values of some other quantities (the dependent variables). Basically, we achieve this speedup by trading space for time. Usually, the definitions of the dependent variables have many intermediate values in common. By saving these values the first time we compute them, and then reusing them later, we can avoid a lot of useless recalculation. This strategy, which can be found in most algorithms textbooks, is called "memoization." 

In implementing various geometries, we have already developed code and techniques for making memoization an automatic part of encoding a geometry. In this tutorial, we describe how to make use of this code.  

== Implementation Details ==
The underlying implementation of the pipeline is designed to solve two problems in a fairly user-friendly way:
  # We would like to be able to identify geometric quantities with positions on the triangulation. For example, when doing mathematics we can speak of the dihedral angle associated with a particular edge on a tetrahedron. We would like to be able to write code in the same way.
  # We would like memoization to be nearly automatic. In other words, when writing a particular quantity, the programmer shouldn't have to think much about what happens to memoize that quantity's value.
 
We view quantities as being specified by 3 pieces of information:
  # A position on the triangulation.
  # A definition of the other quantities (if any) needed to calculate the value of the current quantity, and where those quantities can be found on the triangulation.
  # A formula for calculating a quantity's value, given the values of the other quantities it depends on.

Usually, specifying just these 3 pieces of information is enough to create a new type of quantity. To help speed the development of quantities, we have developed a Ruby script, `makeQuantity.rb`, that generates much of the source code. This can be invoked at the command line as follows:
{{{
> ruby makeQuantity.rb [quantity]
}}}
This produces two files, `[quantity].h` and `[quantity].cpp`.

=== The anatomy of `quantity.h` ===
In `C++`, header files serve several purposes. Among other uses, a header file can:
 * Specify dependencies on other parts of the project.   
 * Define an interface for other parts of your project to use. This includes:
    * Definitions for new data-types (like classes).
    * Definitions for procedure calls (what arguments a procedure takes, and what it returns).
By default, `makeQuantity.rb` gives you the following header file to use (here, we chose `quantity/QUANTITY` as the quantity name, in practice, this is filled out by the script). 

FURTHER DISCUSSION HERE 

{{{
#ifndef QUANTITY_H_
#define QUANTITY_H_

#include "geoquant.h"
#include "triposition.h"

/* This is where you load the headers of the *
 * quantities you require.                   */

class quantity : public virtual GeoQuant {
protected:
  quantity( SIMPLICES );
  void recalculate();
  /* The quantity references you need go here. */

public:
  ~quantity();
  static quantity* At( SIMPLICES );
  static void CleanUp();
};
#endif /* QUANTITY_H_ */
}}}

=== The anatomy of `quantity.cpp` ===

DISCUSSION OF THE CPP FILE HERE

{{{
#include "quantity.h"

#include <map>
#include <new>
using namespace std;

#define map<TriPosition, quantity*, TriPositionCompare> quantityIndex 
static quantityIndex* Index = NULL;

quantity::quantity( SIMPLICES ){}

void quantity::recalculate(){}

quantity::~quantity(){}

quantity* quantity::At( SIMPLICES ){
  TriPosition T( NUMSIMPLICES, SIMPLICES );
  if( Index == NULL ) Index = new quantityIndex();
  quantityIndex::iterator iter = Index->find( T );

  if( iter == Index->end() ){
    quantity* val = new quantity( SIMPLICES );
    Index->insert( make_pair( T, val ) );
    return val;
  } else {
    return iter->second;
  }
}

void quantity::CleanUp(){
  if( Index == NULL ) return;
  quantityIndex::iterator iter;
  for(iter = Index->begin(); iter != Index->end(); iter++)
    delete iter->second;
  delete Index;
}
}}}
== Example ==
Adding a quantity to the Einstein-Hilbert-Regge geometry. (More details and diagrams will go here)

== Common Mistakes ==
A panoply of debugging hints should go here.

== Fancier Tricks ==
Techniques for less common quantities go here.

== Limitations, Areas to Improve ==
Discussion of the current topological assumptions our code makes.