%html2tex: Version  2.7 of June 17, 2008.
%Written by  F.J. Faase.  http://www.iwriteiam.nl/

\documentclass[10pt]{article}%
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}%
\setcounter{MaxMatrixCols}{30}
%TCIDATA{OutputFilter=latex2.dll}
%TCIDATA{Version=5.00.0.2606}
%TCIDATA{CSTFile=40 LaTeX article.cst}
%TCIDATA{Created=Friday, March 30, 2007 00:21:27}
%TCIDATA{LastRevised=Wednesday, June 10, 2009 11:42:33}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=Manual}
%TCIDATA{<META NAME="DocumentShell" CONTENT="Standard LaTeX\Blank - Standard LaTeX Article">}
%TCIDATA{Language=American English}
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\geometry{left=1in,right=1in,top=1in,bottom=1in}

\begin{document}

%%%%% BEGINNING OF DOCUMENT BODY %%%%%
% html: Beginning of file: `clean.html'
% DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
%  This is a (PRE) block.  Make sure it's left aligned or your toc title will be off. 

\section*{\texttt{Approximator}}

\label{f0}\begin{quotation} \end{quotation}
\subsection*{Key Words}

\begin{quotation} curvature flow, differential equations, Euler's method, Runga Kutta\end{quotation}

\subsection*{Authors}

\begin{itemize}\item  Joe Thomas
\item  Alex Henniges
\end{itemize}

\subsection*{Introduction}

\begin{quotation} The Approximator class runs a curvature flow using one of several methods. The class itself is abstract and the method is chosen by the instantiating object.\end{quotation}

\subsection*{Subsidiaries}

\begin{quotation} Functions:\end{quotation}
\begin{itemize}
\item  \mbox{$[$}Functions\#Approximator::run run\mbox{$]$}
\end{itemize}
\begin{quotation} Sub-classes:\end{quotation}
\begin{itemize}
\item  EulerApprox
\item  RungaApprox
\end{itemize}
\begin{quotation} Public Variables:\end{quotation}
\begin{itemize}
\item  radiiHistory
\item  curvHistory
\item  areaHistory
\item  volumeHistory
\end{itemize}

\subsection*{Description}

\begin{quotation} The \texttt{Approximator} class is the shell for running a curvature flow. The class provides the functionality to determine what system of differential equations to use, how to perform a step, and even which values to record for later use. The system is provided by the user at run-time and is defined to be a function that takes in an empty array of \texttt{double}s and fills the array with the values calculated in the system of equations. The \texttt{Approximator} class is abstract with an abstract method \texttt{step}. A class that extends \texttt{Approximator} implements \texttt{step} with the method of approximation to use (i.e Euler's method). Lastly, the \texttt{Approximator} stores values after each \texttt{step} of a flow according to which values were requested at construction. Values include radii, curvatures, areas, and volumes. These histories can then be accessed directly from the \texttt{Approximator} object.\end{quotation}

\subsection*{Constructor}

\begin{quotation} The constructor takes in a function that defines a system of differential equations and a string of characters representing what histories to record. For the function to be a \texttt{sysdiffeq} it must not return a value and its only parameter is an array of doubles that will be filled in with values after the function completes. The history string must be nul-terminated and consisting of only valid characters. The valid characters currently are:\end{quotation}
\begin{itemize}
\item  r - Record radii
\item  2 - Record two-dimensional curvatures
\item  3 - Record three-dimensional curvatures
\item  a - Record areas
\item  v - Record volumes
\end{itemize}
\begin{quotation} One cannot list both two- and three-dimensional curvatures.{\small{\begin{verbatim} 
  typedef void (*sysdiffeq)(double derivs[]);
  Approximator(sysdiffeq funct, char* histories);
  \end{verbatim}
}}
\end{quotation}
\subsection*{Practicum}

\begin{quotation} This example will show how to run a Yamabe curvature flow on the pentachoron using precision and accuracy bounds (see \mbox{$[$}Functions\#run run\mbox{$]$}) while recording radii, curvatures, and volumes. It will show how to initialize the system and also how to print out results at the end.{\small{\begin{verbatim} 
int main(int argc, char** argv) {
   map<int, Vertex>::iterator vit;
   map<int, Edge>::iterator eit;
   map<int, Face>::iterator fit;
   map<int, Tetra>::iterator tit;
     
   vector<int> edges;
   vector<int> faces;
   vector<int> tetras;
    
    
   time_t start, end;
   
   // File to read in triangulation from.
   char from[] = "./Triangulation Files/3D Manifolds/Lutz Format/pentachoron.txt";
   // File to convert to proper format.
   char to[] = "./Triangulation Files/manifold converted.txt";
   // Convert, then read in triangulation.
   make3DTriangulationFile(from, to);
   read3DTriangulationFile(to);

   int vertSize = Triangulation::vertexTable.size();
   int edgeSize = Triangulation::edgeTable.size();
   
   // Set the radii
   for(int i = 1; i <= vertSize; i++) {
      Radius::At(Triangulation::vertexTable[i])->setValue(1 + (0.5 - i/5.0) );        
   }
   // Set the etas
   for(int i = 1; i <= edgeSize; i++) {
       Eta::At(Triangulation::edgeTable[i])->setValue(1.0);
   }

   // Construct an Approximator object that uses the Euler method and Yamabe flow while
   // recording radii, 3D curvatures, and volumes.
   Approximator *app = new EulerApprox((sysdiffeq) Yamabe, "r3v");

   // Run the Yamabe flow with precision and accuracy bounds of 0.0001 and stepsize of 0.01
   app->run(0.0001, 0.0001, 0.01);

   // Print out radii, curvatures and volumes
   printResultsStep("./Triangulation Files/ODE Result.txt", &(app->radiiHistory), &(app->curvHistory));
   printResultsVolumes("./Triangulation Files/Volumes.txt", &(app->volumeHistory));

   return 0;
}
\end{verbatim}
}}
\end{quotation}    
% html: End of file: `clean.html'

%%%%% END OF DOCUMENT BODY %%%%%
% In the future, we might want to put some additional data here, such
% as when the documentation was converted from wiki to TeX.
%

\end{document}
