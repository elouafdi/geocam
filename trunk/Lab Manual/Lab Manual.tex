\documentclass[12pt]{article}%
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{indentfirst}%
\usepackage{amsmath}%
\setcounter{MaxMatrixCols}{30}%
\usepackage{amsfonts}%
\usepackage{graphicx}
%TCIDATA{OutputFilter=latex2.dll}
%TCIDATA{Version=5.00.0.2606}
%TCIDATA{CSTFile=40 LaTeX article.cst}
%TCIDATA{Created=Friday, March 30, 2007 00:21:27}
%TCIDATA{LastRevised=Friday, June 05, 2009 01:27:43}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=Manual}
%TCIDATA{<META NAME="DocumentShell" CONTENT="Standard LaTeX\Blank - Standard LaTeX Article">}
%TCIDATA{Language=American English}
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgment}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\geometry{left=1in,right=1in,top=1in,bottom=1in}
\begin{document}
\section*{\texttt{Approximator::run}}

\subsection*{Function Prototype}

\texttt{run ( \textbf{int} numsteps, \textbf{double} stepsize)} \	

\texttt{run (\textbf{double} precision, \textbf{double} accuracy, \textbf{double} stepsize)} \	

\subsection*{Key Words}
flow, curvature, stepsize, precision, accuracy, approximator

\subsection*{Authors}
Joseph Thomas, Alex Henniges

\subsection*{Introduction}

The \texttt{run} function of the Approximator class runs a system of differential equations representing a curvature flow for either a number of steps or until the values are within a desired accuracy and precision. The system to use and how steps are performed is given in the constructor of the approximator. The type of run is based on the parameters given.\ 

\subsection*{Subsidiaries}

Functions:

\qquad step

\qquad isPrecise

\qquad isAccurate

\qquad getLatest

\qquad\qquad recordState

Global Variables: radii, curvatures

Local Variables: \textbf{int} numsteps, \textbf{double} stepsize, \textbf{double} precision, \textbf{double} accuracy

\subsection*{Description} \label{run.description}

If the \texttt{run} function is given a number of steps, it will call its step function that number of times. In between steps, the \texttt{run} function will record the current state of any values that have been requested to be recorded (this is specified in the constructor). \	

If the \texttt{run} function is given a precision and accuracy, it will continue to call its step function until the desired quantities (curvature in two dimensions and curvature divide by radius in three dimensions) have converged within the precision and accuracy bounds. Precision is defined to be the difference between subsequent values of a quantity. Therefore, precision is a measure of how much a value is changing. Accuracy is defined to be the difference in value between quantities. Therefore, accuracy is a measure of how close values are to each other. In between steps, the \texttt{run} function will record the current state of any values that have been requested to be recorded (this is specified in the constructor). \	

The \texttt{run} function and the overarching Approximator class exists as an improvement over the curvature flows of earlier versions of the Geocam project. The \texttt{run} function provides the skeleton that is similar for all types of curvature flows. Beyond the constructor, this should be the only thing a user calls from the Approximator class.  \	

\subsection*{Practicum}

Example:
\begin{verbatim}
// Create an approximator that uses the Euler method on a Yamabe flow.
Approximator *app = new EulerApprox(Yamabe);

// run a Yamabe flow for 300 steps with a stepsize of 0.01.
app->run(300, 0.01);
// run with a precision and accuracy bounds of 0.0001 and a stepsize of 0.01
app->run(0.0001, 0.0001, 0.01);
\end{verbatim} \	

\subsection*{Limitations}

The \texttt{run} function is limited in the systems of differential equations that it can \texttt{run}. It is designed to run with curvature flows and, when precision and accuracy are used, expects the values to converge. If a precision/accuracy run is performed on a flow that does not converge, the \texttt{run} function will not stop. If a new curvature flow is created whose convergence is not the usual (as in curvature divided by radius in Yamabe flow) then the \texttt{run} function will have to be modified to accommodate for this.  \ 

\subsection*{Revisions}

subversion 659, 5/1/09, Initial \texttt{run} function uploaded to the code.
subversion 679, 6/3/09, \texttt{run} function modified to work with new Geometry structure.
subversion 761, 6/12/09, \texttt{run} function modified to work with new quantity structure.

\subsection*{Testing}

The function was tested by performing two and three dimensional flows on familiar triangulations. The start and end values for radii and curvature was then compared with our expected values. The expected values were obtained from the earlier curvature flows we had (see \ref{run.description}). We also checked that the end values were within the precision and accuracy bounds when they were in effect.  \ 

\subsection*{Future Work}

No future work is planned at this time, though possible changes would include providing for more general systems to be able to run. This would involve changing the way precision and accuracy are determined as well as what values are recorded. \	

\section*{\texttt{Geoquant::\texttt{At}}}

\subsection*{Function Prototype}

\texttt{Geoquant* Geoquant::At(Simplex s1, ...)}

\subsection*{Key Words}
geoquant, recalculate, dependent, triposition, simplex

\subsection*{Authors}
Joseph Thomas

\subsection*{Introduction}
The \texttt{At} function is defined for every type of geoquant as a way to retrieve that quantity. Once the quantity is retrieved, a value can be set or asked of the quantity. A quantity is retrieved by providing a list of simplices that describe the position of the quantity in the triangulation. \	

\subsection*{Subsidiaries}

Functions: getSerialNumber

Global Variables: map

Local Variables: possible list of simplices

\subsection*{Description}
The \texttt{At} function is a little different for every type of geoquant, but in all cases it is a static function for that class that serves as an object retrieval in place of a constructor. The function takes as a parameter a list of simplices which may be different for each type of geoquant. The list is the natural description of where the quantity is in the triangulation. For example, a radius is described by a vertex, whereas an angle is described as a vertex on a certain face. The \texttt{At} function returns a pointer to the requested quantity. \	

When the \texttt{At} function is called, it searches a local map for a quantity with the given list of simplices. If it is found, a pointer to that quantity in the map is simply returned. If it is not found, the quantity is constructed and placed into the map. If the construction of the object requires other types of quantities not yet created, then these will be constructed automatically at this time. Lastly, this quantity is returned. \	

The constructor is hidden from the user for several reasons. The first is that this avoids redundant construction and the need for an encapsulating object to hold a large set of geoquants (like the Geometry class in a previous version). In the same vein, the need for an initial build step and a required order of construction is removed. In addition, this is an efficiency improvement as quantities that are never requested are never created, decreasing memory use and large dependency trees which can take a while for an invalidate to traverse. \	

\subsection*{Practicum}

Example:
\begin{verbatim}
//  Get  the  Radius  quantity  from  the  first  vertex  in  the  triangulation.
Radius  *r  =  Radius::At(Triangulation::vertexTable[0]);
//  Get  the  angle  of  vertex  v  incident  on  face  f
Vertex  v;
Face  f;
...
EuclideanAngle  *ang  =  EuclideanAngle::At(v,  f);
\end{verbatim} \	

\subsection*{Limitations}

The \texttt{At} function is limited in that a specific set of simplices will always return the exact same object. While this is in fact the design goal, this can limit one's ability to modify an object as a change in one place will affect its use elsewhere in the code. The function also will require the user to handle pointers, a powerful yet fragile and sometimes daunting aspect of the programming language. \ 

\subsection*{Revisions}
subversion 761, 6/12/09, A working copy of \texttt{At} and the Geoquant system. \	

\subsection*{Testing}
The \texttt{At} function was tested in small modularized systems, then tested in a three dimensional flow, which required many varied uses of \texttt{At}. Some retrieved quantities had their values set while others had their values accessed and compared with what mathematica calculations predicted. \	

\subsection*{Future Work}

No future work is planned at this time. \	



\end{document}